
<h1>TACAS 2022 Submission #27</h1>

<p>For the regular tool paper submission #26 TempAS: A Temporal Verification Tool for Mixed Async-Sync Concurrency </p>

<h4 id="quick-links">Quick links</h4>
<ul>
  <li>Browse the development at GitHub: <a href="https://github.com/songyahui/Semantics_HIPHOP">online</a></li>
  <li>A demo Page: <a href="http://loris-5.d2.comp.nus.edu.sg/MixedSyncAsync/introduction.html">online</a></li>
  <li>VirtualBox image: <a href="">online</a></li>
</ul>


<h3>Getting started</h3>
<p>The artifact consists of i) <em> a Front End: Forward Verifier</em>; and ii) <em> a Back End: the term rewriting system</em>.<br>
There are two ways to evaluate the artifact:</p>
<ul>
  <li>by using a virtual machine (VM) provided;</li>
  <li>by using your local machine with <code>OCaml version 4.10.0</code>. 

</ul>
Below, we provide guidance for both approaches.


<h3>Using the Virtual Machine</h3>
<p>You need to get a <a href="https://www.virtualbox.org/">VirtualBox</a> (tested w/ version 6.1.26) on your system and import the VM
<code class="language-plaintext highlighter-rouge">pwt.ova</code>. Please, note the following:</p>
<ul>
  <li>The VM should be provided with at least 4GB of RAM.</li>
  <li>The VM is better to be provided with 4 CPUs (but 2 CPUs should be enough).</li>
  <li>The VM is a Ubuntu 18.04 with <code class="language-plaintext highlighter-rouge">OCaml</code>, <code class="language-plaintext highlighter-rouge">vim</code> and <code class="language-plaintext highlighter-rouge">emacs</code> being set-up.</li>
  <li>Username and password are both <code>tacas2022</code>.</li>
</ul>

<p>The source code can be found in the folder <code class="language-plaintext highlighter-rouge">/home/tacas2022/Semantics_HIPHOP</code>. 
  <br>To compile it,
you need to run <code class="language-plaintext highlighter-rouge">cd /home/tacas2022/Semantics_HIPHOP &amp;&amp; dune build</code> in a terminal. 


<h3 id="using-your-own-coq-setup-with-opam">Using your local machine</h3>
<li>Check out the instructions on GitHub: <a href="https://github.com/songyahui/Semantics_HIPHOP">online</a></li>
  

<h2 id="checking-the-artifacts-code">Checking the artifact’s code</h2>
<p>After the project is compiled, you may want to check how the main definitions and results in Coq are related to the ones in the paper.</p>

<table>
  <thead>
    <tr>
      <th>Paper</th>
      <th>Description</th>
      <th>Coq file</th>
      <th>Coq statements</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>§4.1</td>
      <td>definitions of statements <em>S</em> and expressions <em>M</em></td>
      <td><code class="language-plaintext highlighter-rouge">Language.v</code></td>
      <td><code class="language-plaintext highlighter-rouge">Expr.t</code> and <code class="language-plaintext highlighter-rouge">Stmt.t</code></td>
    </tr>
    <tr>
      <td>§4.3, Def. 4.2</td>
      <td>a definition of predicate transformers</td>
      <td><code class="language-plaintext highlighter-rouge">PredTransformer.v</code></td>
      <td><code class="language-plaintext highlighter-rouge">Record predTransformer</code></td>
    </tr>
    <tr>
      <td>§4.3, Def. 4.4; §A.3, Def. A.2</td>
      <td>a definition of pomsets with predicate transformers; a definition of complete pomsets</td>
      <td><code class="language-plaintext highlighter-rouge">Pomset.v</code></td>
      <td><code class="language-plaintext highlighter-rouge">Record pomset</code>, <code class="language-plaintext highlighter-rouge">Record wf</code> <br /> (well-formedness predicate), and <code class="language-plaintext highlighter-rouge">Record complete</code></td>
    </tr>
    <tr>
      <td>§4.3, Fig. 1 and <br /> §9.4, Def. 9.6</td>
      <td>the PwT semantics extended to allow if-closure</td>
      <td><code class="language-plaintext highlighter-rouge">Semantics.v</code></td>
      <td><code class="language-plaintext highlighter-rouge">Inductive Semantics</code></td>
    </tr>
  </tbody>
  <tbody>
    <tr>
      <td>§4.3, Lemma 4.5a</td>
      <td><code class="language-plaintext highlighter-rouge">skip</code> as an identity element for the semicolon operator</td>
      <td><code class="language-plaintext highlighter-rouge">SeqSkipId.v</code></td>
      <td>lemmas  <code class="language-plaintext highlighter-rouge">skip_seq_id_left</code> <br /> and <code class="language-plaintext highlighter-rouge">skip_seq_id_right</code></td>
    </tr>
    <tr>
      <td>§4.3, Lemma 4.5b</td>
      <td>associativity of the semicolon operator</td>
      <td><code class="language-plaintext highlighter-rouge">SeqAssoc.v</code></td>
      <td>lemma <code class="language-plaintext highlighter-rouge">seq_assoc</code></td>
    </tr>
    <tr>
      <td>§4.3, Lemma 4.6e</td>
      <td>distribution of the if operator over semicolon</td>
      <td><code class="language-plaintext highlighter-rouge">IfClosure.v</code></td>
      <td>lemma <code class="language-plaintext highlighter-rouge">if_closure</code></td>
    </tr>
  </tbody>
</table>

<p>Our proofs of the main lemmas use the following axioms (and no other assumptions):</p>
<ul>
  <li>Excluded middle, XM (<code class="language-plaintext highlighter-rouge">classic</code> from <code class="language-plaintext highlighter-rouge">Coq.Logic.Classical_Prop</code>);</li>
  <li>(Dependent) Functional Extensionality, (D)FE (<code class="language-plaintext highlighter-rouge">functional_extensionality_dep</code> from <code class="language-plaintext highlighter-rouge">Coq.Logic.FunctionalExtensionality</code>);</li>
  <li>Constructive Definite Description, CDD (<code class="language-plaintext highlighter-rouge">constructive_definite_description</code> from <code class="language-plaintext highlighter-rouge">Coq.Logic.Description</code>).</li>
</ul>

<p>You may check that by taking a look at files</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">skip_seq_id_left.axioms.out</code>, <code class="language-plaintext highlighter-rouge">skip_seq_id_right.axioms.out</code>, <code class="language-plaintext highlighter-rouge">seq_assoc.axioms.out</code>, and <code class="language-plaintext highlighter-rouge">if_closure.axioms.out</code>.</li>
</ul>

<p>They are generated during the project compilation by <code class="language-plaintext highlighter-rouge">Print Assumptions</code> instructions at the end of <code class="language-plaintext highlighter-rouge">SeqSkipId.v</code>, <code class="language-plaintext highlighter-rouge">SeqAssoc.v</code>, and <code class="language-plaintext highlighter-rouge">IfClosure.v</code> files.</p>

<p>To check that the project does not contain admitted facts, you may want to run the following script from the project’s root folder:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">grep </span>dmit src/<span class="k">*</span>.v

</code></pre></div></div>

<h3 id="description-of-the-projects-files">Description of the project’s files</h3>

<h4 id="basic-definitions-of-the-semantics">Basic definitions of the semantics</h4>
<ul>
  <li><code class="language-plaintext highlighter-rouge">Events.v</code> – a definition of events (§4.1)</li>
  <li><code class="language-plaintext highlighter-rouge">Language.v</code> – definitions of statements <em>S</em> and expressions <em>M</em> (§4.1)</li>
  <li><code class="language-plaintext highlighter-rouge">Formula.v</code> – a language of formulas Φ (§4.1)</li>
  <li><code class="language-plaintext highlighter-rouge">Action.v</code> — a definition of actions and related notions (§4.2)</li>
  <li><code class="language-plaintext highlighter-rouge">PredTransformer.v</code> — a definition of predicate transformers (§4.3, Def. 4.2)</li>
  <li><code class="language-plaintext highlighter-rouge">Pomset.v</code> — a definition of pomsets with predicate transformers (§4.3, Def. 4.4)</li>
  <li><code class="language-plaintext highlighter-rouge">Semantics.v</code> — the PwT semantics extended to allow if-closure (§4.3, Fig. 1 and §9.4, Def. 9.6)</li>
</ul>

<h4 id="properties-of-the-semantics">Properties of the semantics</h4>
<ul>
  <li><code class="language-plaintext highlighter-rouge">SeqSkipId.v</code> — <code class="language-plaintext highlighter-rouge">skip</code> as an identity element for the semicolon operator (§4.3, Lemma 4.5a)</li>
  <li><code class="language-plaintext highlighter-rouge">SeqAssoc.v</code> — associativity of the semicolon operator (§4.3, Lemma 4.5b)</li>
  <li><code class="language-plaintext highlighter-rouge">IfClosure.v</code> — distribution of the if operator over semicolon (§4.3, Lemma 4.6e)</li>
</ul>

<h4 id="auxiliary-definitions-and-lemmas">Auxiliary definitions and lemmas</h4>
<ul>
  <li><code class="language-plaintext highlighter-rouge">AuxDef.v</code>, <code class="language-plaintext highlighter-rouge">AuxRel.v</code>, <code class="language-plaintext highlighter-rouge">SeqBuilder.v</code></li>
</ul>

<h2 id="pwter">PwTer</h2>

<p>PwTer can be found on the desktop of the virtual machine described above, by following the <code class="language-plaintext highlighter-rouge">PwTer</code> shortcut on the
desktop.</p>

<p>Alternatively, it can be built on your own machine by following the instructions in <a href="https://github.com/graymalkin/pomsets-with-predicate-transformers">the
project</a>’s README.</p>

<p>Once the tool is built, to replicate the results presented in the paper, navigate to the <code class="language-plaintext highlighter-rouge">data</code> directory of the PwTer
sources and run <code class="language-plaintext highlighter-rouge">make check</code>. This will evaluate the Java Causality Test Cases.</p>

<h3 id="tool-structure">Tool structure</h3>

<p>Most of the source is boiler plate to tie together parsers, the two interesting files are:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">src/Preliminaries.ml</code> contains the interface to Z3</li>
  <li><code class="language-plaintext highlighter-rouge">src/PomsetPTSeq.ml</code> implements the semantics as presented in Figure 1, with register recycling. The paper’s rules are referenced in comments like <code class="language-plaintext highlighter-rouge">(* M6 *)</code> and <code class="language-plaintext highlighter-rouge">(* R4a *)</code>.</li>
</ul>

<p>The tool has been written to be faithful to the mathematics without too much deviation for efficiency’s sake. The
majority of the complexity is in the implementation of <code class="language-plaintext highlighter-rouge">seq_rule</code> and <code class="language-plaintext highlighter-rouge">if_rule</code>, as these have to implement merging. In
PwTer, all events have globally unique identifiers, so possible valid merges have to be calculated at these compositions
and new labellings must be produced. This yields quite a lot of fiddly maps which have to be applied carefully to
preserve the semantics.</p>
